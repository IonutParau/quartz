# This was written when
# the language was very new
# thus it is written
# only with stuff available at that time
# it is being updated over time as new features are added

local data = []
local width = 80
local height = 32

{
	local x = 0
	while x < (width*height) {
		append(data, false)
		x = x + 1
	}
}

local wrap = fun(x, n) {
	while x >= n {
		x = x - n
	}
	while x < 0 {
		x = x + n
	}
	return x
}

local get = fun(x, y) {
	x = wrap(x, width)
	y = wrap(y, height)

	return data[x + (y * width)]
}

local set = fun(x, y, val) {
	x = wrap(x, width)
	y = wrap(y, height)

	data[x + (y * width)] = val
}

local gen = 0
local runs = 1000

local units = ["B", "KiB", "MiB", "GiB", "TiB"]

local formatMem = fun(x) {
	local unit = 0

	# theoretical out of bounds error
	# dont care
	while x >= 1024 {
		x = x / 1024
		unit = unit + 1
	}

	x = x * 100
	x = x // 100

	return x .. units[unit] 
}

local render = fun() {
	# term escape to clear line
	io.write("\e[0K")
	local y = 0
	{
		local i = 0
		local t = gen / runs
		while i < width {
			local p = i / width
			if p <= t {
				io.write("=")
			}
			if p > t {
				io.write(" ")
			}
			i = i + 1
		}
		io.writeln(gen, " (peak - ", formatMem(gc.peak()), ") ", formatMem(gc.count()))
	}
	while y < height {
		local x = 0
		while x < width {
			if get(x, y) {
				io.write("#")
			} else {
				io.write(" ")
			}
			x = x + 1
		}
		io.writeln()
		y = y + 1
	}
	# term escape to move cursor up
	io.write("\e[", height+1, "A")
}

local count = fun(x, y) {
	local n = 0
	if get(x+1, y) { n = n + 1 }
	if get(x-1, y) { n = n + 1 }
	if get(x+1, y+1) { n = n + 1 }
	if get(x+1, y-1) { n = n + 1 }
	if get(x, y+1) { n = n + 1 }
	if get(x, y-1) { n = n + 1 }
	if get(x-1, y+1) { n = n + 1 }
	if get(x-1, y-1) { n = n + 1 }
	return n
}

local update = fun() {
	# rip GC
	# this simulation is intentionally not super optimized
	# to be more representative
	local newData = []
	local y = 0
	while y < height {
		local x = 0
		while x < width {
			local cur = get(x, y)
			local n = count(x, y)
			if get(x, y) {
				if n < 2 { cur = false }
				if n > 3 { cur = false }
			} else {
				if n == 3 {
					cur = true
				}
			}
			append(newData, cur)
			x = x + 1
		}
		y = y + 1
	}
	data = newData
}

local placeAcorn = fun(x, y) {
	set(x, y, true)

	set(x+1, y+1, true)
	set(x+2, y+1, true)
	set(x+3, y+1, true)

	set(x-2, y-1, true)
	set(x-2, y+1, true)
	set(x-3, y+1, true)
}

local cx = width//2
local cy = height//2

# seed
placeAcorn(cx, cy)
placeAcorn(cx+5, cy+10)
placeAcorn(cx-10, cy-2)
placeAcorn(cx, cy+15)

while gen < runs {
	gen = gen + 1

	if gen == (runs / 2) {
		placeAcorn(cx-16, cy+17)
	}

	# so we can have a benchmark mode
	if len(argv) == 1 {
		render()
	}
	update()
}

io.write("\e[0J")
io.flush()
